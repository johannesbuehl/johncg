<html>
	<style>
		:root {
			font-size: 0.125vw;
		}

		body {
			margin: 0px;

			background-color: transparent;

			overflow: hidden;

			user-select: none;
		}
		
		#main {
			opacity: 0;

			height:100%;

			background-repeat: no-repeat;
			background-position: center;
			background-size: cover;
		}

		#time {
			text-shadow: calc(1em / 16) calc(1em / 16) calc(1em / 8) black;

			position: absolute;

			font-family: "Bahnschrift";

			font-size: 1em;

			color: white;
		}

		#time > span {
			display: inline-block;
			text-align: center;
			width: 1ch;
		}

		#time > span.colon {
			display: inline;
		}

		#main.show {
			opacity: 1;

			transition: opacity 0.5s;
		}

		#main.stop {
			opacity: 0;

			transition: opacity 1s;
		}
	</style>
	<!-- ------------------------------------------------------------------- -->
	<head>
		<title>
			JohnCG - Countdown-template
		</title>
	</head>
	<!-- ------------------------------------------------------------------- -->
	<body>
		<div id="main">
			<div id="time">
			</div>
		</div>
	</body>
	<!-- ------------------------------------------------------------------- -->
	<script>
		let updateInterval;
		const spans = {

		};
		let data;

		const end_time = new Date();

		let end_time_sign;

		function update(str_args) {
			// clear the old-state
			clearInterval(updateInterval);
			
			data = JSON.parse(str_args);
			
			// if requested, diable transition-effects
			if (data.mute_transition) {
				document.querySelector("#main").style.transitionProperty = "none";
			} else {
				document.querySelector("#main").style.transitionProperty = "";
			}
			
			// create the individual spans for the numbers
			spans.hours = [
				document.createElement("span"),
				document.createElement("span")
			];
			spans.minutes = [
				document.createElement("span"),
				document.createElement("span")
			];
			
			if (data.showSeconds === true) {
				spans.seconds = [
					document.createElement("span"),
					document.createElement("span")
				];
			}
			
			// create the individual spans
			const time_div = document.querySelector("#time");

			const colon_hm = document.createElement("span");
			colon_hm.innerText = ":";
			colon_hm.id = "colon_hm";
			colon_hm.classList.add("colon");

			Object.entries(spans).forEach(([key, val]) => {
				val.id = key;

				if (key === "seconds") {
					const colon_ms = colon_hm.cloneNode(true);
					colon_ms.id = "colon_ms";
					time_div.append(colon_ms);

				}

				time_div.append(val[0]);
				time_div.append(val[1]);

				if (key === "hours") {
					time_div.append(colon_hm);
				}
			});

			// if the position is undefined, set them to center
			if (data.position.x === undefined) {
				data.position.x = 50;
			}
			if (data.position.y === undefined) {
				data.position.y = 50;
			}

			if (data.fontFormat !== undefined) {
				data.fontFormat.fontSize = `${data.fontFormat.fontSize}em`;

				Object.entries(data.fontFormat).forEach(([key, val]) => {
					time_div.style[key] = val;
				});
			}

			if (data.backgroundImage !== undefined) {
				document.querySelector("#main").style.backgroundImage = `url("${data.backgroundImage.replace(/\\/g, "\\\\")}")`;;
			} 
			if (data.backgroundColor !== undefined) {
				document.querySelector("#main").style.backgroundColor = data.backgroundColor;
			}

			if (data.time !== undefined) {
				const time = data.time.match(/(?<hours>\d+)(?::)(?<minutes>\d\d)((?::)(?<seconds>\d\d))?/);
				end_time.setHours(parseInt(time.groups.hours));
				end_time.setMinutes(parseInt(time.groups.minutes));
				end_time.setSeconds(parseInt(time.groups.seconds));

				end_time_sign = Math.sign(Date.now() - end_time);

				updateInterval = setInterval(function () {
					update_time();
				}, 100);
				position_time();
				update_time();
			}
		}

		function play() {
			document.querySelector("#main").classList.remove("stop");
			document.querySelector("#main").classList.add("show");
		}

		function stop() {
			document.querySelector("#main").classList.remove("show");
			document.querySelector("#main").classList.add("stop");
		}

		function next() {
		}

		function get_remaining_time() {
			const time_remaining = new Date(end_time - Date.now());

			return [
				{
					hours: time_remaining.getUTCHours().toString().padStart(2, "0").split(""),
					minutes: time_remaining.getUTCMinutes().toString().padStart(2, "0").split(""),
					seconds: time_remaining.getUTCSeconds().toString().padStart(2, "0").split("")
				},
				Math.sign(time_remaining) === end_time_sign
			];
		}
		
		const root = document.querySelector(":root");
		const time_div = document.querySelector("#time");

		function position_time() {
				const root_width = root.clientWidth;
				const root_height = root.clientHeight;
				const time_width = time_div.clientWidth;
				const time_height = time_div.clientHeight;

				const free_width_share = 1 - time_width / root_width;
				const free_height_share = 1 - time_height / root_height;

				const left = data.position.x * free_width_share + time_width / root_width / 2;
				const top = data.position.y * free_height_share + time_height / root_height / 2;

				time_div.style.left = `${left}%`;
				time_div.style.top = `${top}%`;

				time_div.style.transform = `translate(-${left}, -${top})`;
		}

		function update_time() {
			const [time, finished] = get_remaining_time();

			if (finished) {
				clearInterval(updateInterval);
			} else {
				// if the hours are 00, don't show them anymore
				if  (time.hours.join("") === "00") {
					if (spans.hours !== undefined) {
						spans.hours[0].remove();
						spans.hours[1].remove();
						document.querySelector("#colon_hm").remove();

						delete spans.hours;

						// re-position everything
						position_time();
					}
				}

				Object.entries(spans).forEach(([key, val]) => {
					val[0].innerText = time[key][0];
					val[1].innerText = time[key][1];
				});
			}
		}
	</script>
</html>